var debug = false;

let activeTab = null;

const EVENT_TYPES = { CHANGE_COMMITTED: "onChangeCommitted", CREATED_NAVIGATION_TARGET: "onCreatedNavigationTarget" }

// The data object which is stored in the session storage and contains information required to control the extension.
// activeTab : The tabId of the tab where the extension is enabled(play button is pressed)
// url : Url of the activeTab
// state : The state of the extension in the current tab or window. The values can be either of [start, stop, pause]
// code : Contains Code generated by the extension or edited in the extension code editor for each tab or window. 
//        Example : {239200808:["cy.visit(\"https://developer.wordpress.org/coding-standards/inline-documentation-standards/javascript/\")","cy.findByRole(\"link\",{\"name\":\"Community\"}).click()"]}
// toggleInspect: A boolean representing whether the inspect is enabled or not for each tab or window. Example : {239200808:false,412319832:true}
var data = { activeTab: -1, url: "", state: "stop", code: {}, toggleInspect: {} };
// Settings object containing information about the extension settings -> selector_order, trim-whether to remove trailing white spaces of the string(label text, text, attribute value etc.) which is used to identify the element and useAllElements-whether to consider all the elements as actionable(click) elements.
var settings = { "selector_order": ["cy.findByRole", "cy.findByText", "cy.findByLabelText", "cy.findByPlaceholderText", "cy.findByTestId", "cy.get"], "trim": true, useAllElements: false };

var codeEditorInitialContent = [`// If you encounter any issues with the extension,`, `// try refreshing the web page or`, `// try by stopping and starting the recording.`, '// Shortcuts:', '// Each shortcut works only on a HTML element', '// 1) Assertions: HOLD ALT KEY + RIGHT CLICK', ''];
// Setting up the required fields if the service worker get's refreshed or activated
chrome.storage.session.get(Object.keys(data)).then((v) => {
    Object.assign(data, v);
});

chrome.storage.local.get(Object.keys(settings)).then((v) => {
    Object.assign(settings, v);
});

/**
 * Sends Message to content_script of a tab with the given tabId
 * @param {number} tabId An integer representing the ID of the tab to send the message to.
 * @param {object} request A JSON object to send as data
 * @param {string} from A string whose value is used by the listeners to filter the messages comming from content_script, popup and background scripts for specific task
 * @param {string} type A string which is used to perform a specific task at the receiver side
 * @param {function(object)} callback A callback to handle response returned from the onMessage listeners.
 */
function sendMessageToContentScript(tabId, request, from = "background", type = "update", callback = (response) => {
    if (chrome.runtime.lastError) {
        if (debug)
            console.log("[background.js] [sendMessageToContentScript] chrome.runtime.lastError for Request :: ", request, " From::", from, "Type::", type);
    }
}) {
    try {
        chrome.tabs.sendMessage(tabId, { from: from, type: type, currentTab: tabId, ...request }, callback);
    } catch (err) {
        if (debug)
            console.log("[background.js] [sendMessageToContentScript] Not able to send message to content script")
    }
}

/**
 * Sends Message to popup and background
 * @param {object} request A JSON object to send as data
 * @param {string} from A string whose value is used by the listeners to filter the messages comming from content_script, popup and background scripts for specific task
 * @param {string} type A string which is used to perform a specific task at the receiver side
 * @param {function(object)} callback A callback to handle response returned from the onMessage listeners.
 */
function sendMessageToPopUp(request, from = "background", type = "update", callback = (response) => {
    if (chrome.runtime.lastError) {
        if (debug)
            console.log("[background.js] [sendMessageToBackground] chrome.runtime.lastError occured for Request :: ", request, " From::", from, "Type::", type);
    }
}) {
    try {
        chrome.runtime.sendMessage({ from: from, type: type, ...request }, callback);
    } catch (err) {
        if (debug)
            console.log("[background.js] [sendMessageToBackground] Not able to send message to popup")
    }
}

/**
 * Adds code to the data for the tab where the extension is enabled and updates the data in the session storage
 * @param {string} code 
 */
function addCode(code) {
    try {
        var codelines = data.code[data.activeTab];
        if (!codelines || codelines.length <= codeEditorInitialContent.length) {
            codelines = [...codeEditorInitialContent, `describe('Automation', () => {`, `  it('Test', () => {`, `  })`, `})`];;
        }
        codelines.splice(-2, 0, "    " + code);
        data.code[data.activeTab] = codelines;
        chrome.storage.session.set(data);

        sendMessageToContentScript(data.activeTab, { code: data.code });
        sendMessageToPopUp(data);
    } catch (err) {
        if (debug)
            console.log("[background.js] [addCode] Error :: ", err);
    }
}

function addWebNavigation(tabId, details, eventType = EVENT_TYPES.CHANGE_COMMITTED) {
    try {
        if (tabId == data.activeTab && data.state == "start" && !details.url.startsWith("chrome://")) {
            var expectedTransitionTypes = ["typed", "auto_bookmark", "generated", "form_submit", "keyword", "keyword_generated"];
            if (eventType == EVENT_TYPES.CREATED_NAVIGATION_TARGET) {
                addCode(`//Navigated to new page`);
            }
            if (eventType == EVENT_TYPES.CHANGE_COMMITTED) {
                data.url = details.url
                if (expectedTransitionTypes.indexOf(details.transitionType) != -1 || details.transitionQualifiers.indexOf("forward_back") != -1) {
                    if (details.transitionType != "form_submit")
                        addCode(`cy.visit("${details.url}")`);
                    addCode(`cy.url().should('eq','${details.url}')`);
                } else if ((details.transitionType == "link" || details.transitionQualifiers.indexOf("server_redirect") != -1) && details.transitionType != "auto_subframe") {
                    //Navigation happened from  webpage by either clicking a link or from javascript
                    addCode(`cy.url().should('eq','${details.url}')`);
                }
                else if (details.transitionType == "reload") {
                    var code_lines = data.code[data.activeTab] || [];
                    if (code_lines.length <= codeEditorInitialContent.length) {
                        addCode(`cy.visit("${details.url}")`);
                    }
                    addCode("cy.reload()");
                    addCode(`cy.url().should('eq','${details.url}')`);
                }
            }
        }
    } catch (err) {
        if (debug)
            console.log("[background.js] [addWebNavigation] Error :: ", err);
    }
}
// This event is fired when a new window, or a new tab in an existing window, is created to host a navigation.
// TODO :: Handling multiple tabs in cypress
chrome.webNavigation.onCreatedNavigationTarget.addListener(
    function (details) {
        if (debug)
            console.log("onCreatedNavigationTarget Event :: ", details);
        if (details.sourceTabId == data.activeTab) {
            addWebNavigation(data.activeTab, details, EVENT_TYPES.CREATED_NAVIGATION_TARGET);
        }
    }
)
// This event is fired when when a navigation is committed. The document (and the resources it refers to, such as images and subframes)
// might still be downloading, but at least part of the document has been received from the server and the browser has decided to switch to the new document
chrome.webNavigation.onCommitted.addListener(
    function (details) {
        if (debug)
            console.log("onCommitted Event :: ", details);
        addWebNavigation(details.tabId, details, EVENT_TYPES.CHANGE_COMMITTED);
    }
)

// This is to listen for incomming requests/messages from content_script or popup
chrome.runtime.onMessage.addListener(
    function (request, sender, sendResponse) {
        if (debug)
            console.log("[MessageEventListener] [background.js] Received Request :: ", request);

        try {
            if (request.from == "content_script") {
                if (request.type == "init") {
                    chrome.storage.session.get(Object.keys(data)).then((d) => {
                        chrome.storage.local.get(Object.keys(settings)).then((v) => {
                            var tabId = null;
                            if (sender) {
                                if (sender.tab) {
                                    if (sender.tab.id) {
                                        tabId = sender.tab.id;
                                    }
                                }
                            }
                            var _data = {};
                            var _settings = {};
                            for (var k in v) {
                                if (k in settings) {
                                    _settings[k] = v[k];
                                }
                            }
                            for (var k in d) {
                                if (k in data) {
                                    _data[k] = d[k];
                                }
                            }
                            return sendResponse({ current_tab: tabId, data: { ..._data }, settings: { ..._settings } });
                        });
                    });
                }
                else if (request.type == "save") {
                    for (var k in request) {
                        if (k in data) {
                            data[k] = request[k];
                        }
                    }
                    chrome.storage.session.set(data);
                    return sendResponse({ "status": 200 });
                }
                else if (request.type == "update_tab") {
                    if (request.activeTab) {
                        sendMessageToContentScript(request.activeTab, data);
                    }
                }
            }
            else if (request.from == "ping") {
                return sendResponse({ status: 200 });
            }
        } catch (err) {
            return sendResponse({ "status": 500, "error_message": err });
        }
        return true;
    }
);

chrome.storage.onChanged.addListener(
    (changes, areaName) => {
        try {
            if (areaName == "local") {
                for (var k in changes) {
                    if (k in settings) {
                        settings[k] = changes[k].newValue;
                    }
                }
            }
            else if (areaName == "session") {
                for (var k in changes) {
                    if (k in data) {
                        data[k] = changes[k].newValue;
                    }
                }
            }
        } catch (err) {
            if (debug)
                console.log("[background.js] [chrome.storage.onChanged] Error :: ", err);
        }
    }
)

